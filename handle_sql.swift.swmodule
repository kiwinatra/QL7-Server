import Foundation

struct User: Codable {
    let userID: Int
    let username: String
    let email: String
    let phone: String?
    let fullName: String?
    let isAdmin: Bool
    enum CodingKeys: String, CodingKey {
        case userID = "user_id"
        case username, email, phone, fullName = "full_name", isAdmin = "is_admin"
    }
}
struct Account: Codable {
    let accountID: Int
    let userID: Int
    let accountNumber: String
    let accountType: String
    let balance: Double
    let currency: String
    enum CodingKeys: String, CodingKey {
        case accountID = "account_id"
        case userID = "user_id"
        case accountNumber = "account_number"
        case accountType = "account_type"
        case balance, currency
    }
}
struct Transaction: Codable {
    let transactionID: Int
    let accountID: Int
    let amount: Double
    let transactionType: String
    let description: String?
    let transactionDate: Date
    enum CodingKeys: String, CodingKey {
        case transactionID = "transaction_id"
        case accountID = "account_id"
        case amount
        case transactionType = "transaction_type"
        case description
        case transactionDate = "transaction_date"
    }
}
struct Card: Codable {
    let cardID: Int
    let accountID: Int
    let cardNumber: String
    let cardHolder: String
    let expiryDate: String
    let cardType: String
    enum CodingKeys: String, CodingKey {
        case cardID = "card_id"
        case accountID = "account_id"
        case cardNumber = "card_number"
        case cardHolder = "card_holder"
        case expiryDate = "expiry_date"
        case cardType = "card_type"
    }
}
struct APIKey: Codable {
    let keyID: Int
    let apiKey: String
    let secretKey: String
    let isActive: Bool
    enum CodingKeys: String, CodingKey {
        case keyID = "key_id"
        case apiKey = "api_key"
        case secretKey = "secret_key"
        case isActive = "is_active"
    }
}

enum QL7APIError: Error {
    case invalidURL
    case invalidResponse
    case statusCode(Int)
    case decodingError(Error)
    case apiError(String)
}

class QL7APIClient {
    private let baseURL = "https://qt7.storage.drweb.link/__/api"
    private let session: URLSession
    private let apiKey: String
    private let secretKey: String
    init(apiKey: String, secretKey: String) {
        self.apiKey = apiKey
        self.secretKey = secretKey
        self.session = URLSession(configuration: .default)
    }
    
    
    func getUser(userID: Int, completion: @escaping (Result<User, QL7APIError>) -> Void) {
        let endpoint = "/users/\(userID)"
        performRequest(endpoint: endpoint, method: "GET", completion: completion)
    }
    
    func getUserAccounts(userID: Int, completion: @escaping (Result<[Account], QL7APIError>) -> Void) {
        let endpoint = "/users/\(userID)/accounts"
        performRequest(endpoint: endpoint, method: "GET", completion: completion)
    }
    
    func createAccount(userID: Int, accountType: String, currency: String, completion: @escaping (Result<Account, QL7APIError>) -> Void) {
        let endpoint = "/accounts"
        let body: [String: Any] = [
            "user_id": userID,
            "account_type": accountType,
            "currency": currency
        ]
        performRequest(endpoint: endpoint, method: "POST", body: body, completion: completion)
    }
    
    func getTransactions(accountID: Int, fromDate: Date? = nil, toDate: Date? = nil, completion: @escaping (Result<[Transaction], QL7APIError>) -> Void) {
        var endpoint = "/accounts/\(accountID)/transactions"
        if let fromDate = fromDate, let toDate = toDate {
            let dateFormatter = ISO8601DateFormatter()
            endpoint += "?from=\(dateFormatter.string(from: fromDate))&to=\(dateFormatter.string(from: toDate))"
        }
        performRequest(endpoint: endpoint, method: "GET", completion: completion)
    }
    
    func transfer(fromAccountID: Int, toAccountNumber: String, amount: Double, description: String? = nil, completion: @escaping (Result<Transaction, QL7APIError>) -> Void) {
        let endpoint = "/transactions/transfer"
        var body: [String: Any] = [
            "from_account_id": fromAccountID,
            "to_account_number": toAccountNumber,
            "amount": amount
        ]
        if let description = description {
            body["description"] = description
        }
        performRequest(endpoint: endpoint, method: "POST", body: body, completion: completion)
    }
    
    private func performRequest<T: Decodable>(endpoint: String, method: String, body: [String: Any]? = nil, completion: @escaping (Result<T, QL7APIError>) -> Void) {
        guard let url = URL(string: baseURL + endpoint) else {
            completion(.failure(.invalidURL))
            return
        }
        var request = URLRequest(url: url)
        request.httpMethod = method
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(apiKey, forHTTPHeaderField: "X-API-KEY")
        
        let timestamp = String(Int(Date().timeIntervalSince1970))
        request.addValue(timestamp, forHTTPHeaderField: "X-API-TIMESTAMP")
        if let body = body {
            do {
                request.httpBody = try JSONSerialization.data(withJSONObject: body)
            } catch {
                completion(.failure(.decodingError(error)))
                return
            }
        }
        
        let signature = calculateSignature(request: request, secretKey: secretKey)
        request.addValue(signature, forHTTPHeaderField: "X-API-SIGNATURE")
        let task = session.dataTask(with: request) { data, response, error in
            if let error = error {
                completion(.failure(.decodingError(error)))
                return
            }
            guard let httpResponse = response as? HTTPURLResponse else {
                completion(.failure(.invalidResponse))
                return
            }
            guard (200...299).contains(httpResponse.statusCode) else {
                if let data = data, let errorMessage = try? JSONDecoder().decode([String: String].self, from: data)["message"] {
                    completion(.failure(.apiError(errorMessage)))
                } else {
                    completion(.failure(.statusCode(httpResponse.statusCode)))
                }
                return
            }
            guard let data = data else {
                completion(.failure(.invalidResponse))
                return
            }
            do {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                let result = try decoder.decode(T.self, from: data)
                completion(.success(result))
            } catch {
                completion(.failure(.decodingError(error)))
            }
        }
        task.resume()
    }
    private func calculateSignature(request: URLRequest, secretKey: String) -> String {
        var components = [String]()
        
        if let method = request.httpMethod {
            components.append(method.uppercased())
        }
        
        if let url = request.url {
            components.append(url.path)
        }
        
        if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
            components.append(bodyString)
        }
        
        if let timestamp = request.value(forHTTPHeaderField: "X-API-TIMESTAMP") {
            components.append(timestamp)
        }
        let stringToSign = components.joined(separator: "\n")
        let hmac = stringToSign.hmac(algorithm: .sha256, key: secretKey)
        return hmac
    }
}

enum CryptoAlgorithm {
    case sha256
    var algorithm: CCHmacAlgorithm {
        switch self {
        case .sha256: return CCHmacAlgorithm(kCCHmacAlgSHA256)
        }
    }
    var digestLength: Int {
        switch self {
        case .sha256: return Int(CC_SHA256_DIGEST_LENGTH)
        }
    }
}
extension String {
    func hmac(algorithm: CryptoAlgorithm, key: String) -> String {
        let str = self.cString(using: .utf8)
        let strLen = Int(self.lengthOfBytes(using: .utf8))
        let digestLen = algorithm.digestLength
        let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)
        let keyStr = key.cString(using: .utf8)
        let keyLen = Int(key.lengthOfBytes(using: .utf8))
        CCHmac(algorithm.algorithm, keyStr!, keyLen, str!, strLen, result)
        let digest = (0..<digestLen).map { String(format: "%02hhx", result[$0]) }.joined()
        result.deallocate()
        return digest
    }
}

let apiKey = "ваш_api_ключ"
let secretKey = "ваш_секретный_ключ"
let client = QL7APIClient(apiKey: apiKey, secretKey: secretKey)

client.getUser(userID: 123) { result in
    switch result {
    case .success(let user):
        print("Пользователь: \(user.username), email: \(user.email)")
    case .failure(let error):
        print("Ошибка: \(error)")
    }
}

// client.transfer(fromAccountID: 456, toAccountNumber: "7890123456", amount: 1000.0, description: "Оплата услуг") { result in
//     switch result {
//     case .success(let transaction):
//         print("Транзакция выполнена: \(transaction.transactionID), сумма: \(transaction.amount)")
//     case .failure(let error):
//         print("Ошибка перевода: \(error)")
//     }
// }