import Vapor
import JWT
struct AuthMiddleware: AsyncMiddleware { let apiBaseURL = "https://ql7.storage.drweb.link/__/"
func respond(to request: Request, chainingTo next: AsyncResponder) async throws -> Response { let publicRoutes = ["/auth/login", "/auth/register", "/health"] if publicRoutes.contains(request.url.path) { return try await next.respond(to: request) } guard let authHeader = request.headers.bearerAuthorization else { throw Abort(.unauthorized, reason: "Требуется авторизация: Bearer <token>") } let isValid = try await validateToken(authHeader.token, on: request) guard isValid else { throw Abort(.unauthorized, reason: "Недействительный токен") } let user = try await fetchUserData(token: authHeader.token, on: request) request.auth.login(user) return try await next.respond(to: request) } private func validateToken(_ token: String, on request: Request) async throws -> Bool { let client = request.client let response = try await client.post(URI(string: apiBaseURL)) { req in req.headers.bearerAuthorization = BearerAuthorization(token: token) req.headers.contentType = .json } guard response.status == .ok else { return false } struct TokenValidationResponse: Content { let isValid: Bool } return try response.content.decode(TokenValidationResponse.self).isValid } private func fetchUserData(token: String, on request: Request) async throws -> AuthenticatedUser { let userInfoURL = "https:" let response = try await request.client.get(URI(string: userInfoURL)) { req in req.headers.bearerAuthorization = BearerAuthorization(token: token) } guard response.status == .ok else { throw Abort(.unauthorized, reason: "Не удалось получить данные пользователя") } return try response.content.decode(AuthenticatedUser.self) }
} struct AuthenticatedUser: Authenticatable, Content { let id: UUID let email: String let roles: [UserRole] let accounts: [UUID]? var isAdmin: Bool { roles.contains(.admin) }
}
enum UserRole: String, Content { case user case admin case support
} extension Request { var currentUser: AuthenticatedUser { get throws { guard let user = auth.get(AuthenticatedUser.self) else { throw Abort(.unauthorized, reason: "Требуется авторизация") } return user } } func requireRole(_ role: UserRole) throws -> AuthenticatedUser { let user = try currentUser guard user.roles.contains(role) else { throw Abort(.forbidden, reason: "Недостаточно прав") } return user }
} app.get("accounts") { req -> [Account] in let user = try req.currentUser return try await Account.query(on: req.db) .filter(\.$userID == user.id) .all()
} app.post("admin/accounts") { req -> HTTPStatus in let admin = try req.requireRole(.admin) return .created
}