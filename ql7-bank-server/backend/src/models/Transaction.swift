import Vapor
import Fluent
final class Transaction: Model, Content { static let schema = "transactions" @ID(key: .id) var id: UUID? @Field(key: "amount") var amount: Double @Field(key: "currency") var currency: String @Field(key: "type") var type: TransactionType @Field(key: "status") var status: TransactionStatus @Field(key: "description") var description: String? @Parent(key: "sender_account_id") var senderAccount: Account @Parent(key: "receiver_account_id") var receiverAccount: Account @Timestamp(key: "created_at", on: .create) var createdAt: Date? @Timestamp(key: "processed_at", on: .none) var processedAt: Date? init() {} init( id: UUID? = nil, amount: Double, currency: String, type: TransactionType, status: TransactionStatus = .pending, description: String? = nil, senderAccountID: Account.IDValue, receiverAccountID: Account.IDValue ) { self.id = id self.amount = amount self.currency = currency self.type = type self.status = status self.description = description self.$senderAccount.id = senderAccountID self.$receiverAccount.id = receiverAccountID }
} enum TransactionType: String, Codable { case transfer case deposit case withdrawal case payment case fee case interest } enum TransactionStatus: String, Codable { case pending case completed case failed case cancelled case reversed } extension Transaction { struct Migration: AsyncMigration { func prepare(on database: Database) async throws { try await database.schema(Transaction.schema) .id() .field("amount", .double, .required) .field("currency", .string, .required) .field("type", .string, .required) .field("status", .string, .required) .field("description", .string) .field("sender_account_id", .uuid, .required, .references("accounts", "id")) .field("receiver_account_id", .uuid, .required, .references("accounts", "id")) .field("created_at", .datetime) .field("processed_at", .datetime) .create() } func revert(on database: Database) async throws { try await database.schema(Transaction.schema).delete() } }
} extension Transaction { struct Create: Content { var amount: Double var currency: String var type: TransactionType var description: String? var receiverAccountNumber: String } struct Public: Content { var id: UUID? var amount: Double var currency: String var type: TransactionType var status: TransactionStatus var description: String? var senderAccountNumber: String var receiverAccountNumber: String var createdAt: Date? var processedAt: Date? } func toPublic(senderNumber: String, receiverNumber: String) -> Public { Public( id: id, amount: amount, currency: currency, type: type, status: status, description: description, senderAccountNumber: senderNumber, receiverAccountNumber: receiverNumber, createdAt: createdAt, processedAt: processedAt ) }
} extension Transaction { static func createTransfer( amount: Double, currency: String, senderAccount: Account, receiverAccount: Account, description: String? = nil, on db: Database ) async throws -> Transaction { let transaction = Transaction( amount: amount, currency: currency, type: .transfer, status: .pending, description: description, senderAccountID: try senderAccount.requireID(), receiverAccountID: try receiverAccount.requireID() ) try await db.transaction { transactionDB in try await transaction.create(on: transactionDB) senderAccount.balance -= amount receiverAccount.balance += amount try await senderAccount.save(on: transactionDB) try await receiverAccount.save(on: transactionDB) transaction.status = .completed transaction.processedAt = Date() try await transaction.save(on: transactionDB) } return transaction } static func getAccountTransactions(accountID: UUID, on db: Database) async throws -> [Transaction] { try await Transaction.query(on: db) .group(.or) { or in or.filter(\.$senderAccount.$id == accountID) or.filter(\.$receiverAccount.$id == accountID) } .sort(\.$createdAt, .descending) .all() }
}