import Vapor
func accountRoutes(_ app: Application) throws { let accounts = app.grouped("accounts") .grouped(User.guardMiddleware()) accounts.post { req async throws -> Account.Public in let user = try req.auth.require(User.self) let accountData = try req.content.decode(Account.Create.self) let accountNumber = generateAccountNumber() let account = Account( accountNumber: accountNumber, balance: 0, currency: accountData.currency, type: accountData.type, status: .active, userID: try user.requireID() ) try await account.save(on: req.db) return account.toPublic() } accounts.get { req async throws -> [Account.Public] in let user = try req.auth.require(User.self) let accounts = try await Account.query(on: req.db) .filter(\.$user.$id == user.requireID()) .all() return accounts.map { $0.toPublic() } } accounts.get(":accountID") { req async throws -> Account.Public in let user = try req.auth.require(User.self) guard let accountID = req.parameters.get("accountID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID счета") } guard let account = try await Account.query(on: req.db) .filter(\.$id == accountID) .filter(\.$user.$id == user.requireID()) .first() else { throw Abort(.notFound, reason: "Счет не найден") } return account.toPublic() } accounts.patch(":accountID", "close") { req async throws -> Account.Public in let user = try req.auth.require(User.self) guard let accountID = req.parameters.get("accountID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID счета") } guard let account = try await Account.query(on: req.db) .filter(\.$id == accountID) .filter(\.$user.$id == user.requireID()) .first() else { throw Abort(.notFound, reason: "Счет не найден") } guard account.status == .active else { throw Abort(.badRequest, reason: "Только активные счета могут быть закрыты") } guard account.balance == 0 else { throw Abort(.badRequest, reason: "Нельзя закрыть счет с ненулевым балансом") } account.status = .closed try await account.save(on: req.db) return account.toPublic() } accounts.get(":accountID", "transactions") { req async throws -> [Transaction.Public] in let user = try req.auth.require(User.self) guard let accountID = req.parameters.get("accountID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID счета") } guard try await Account.query(on: req.db) .filter(\.$id == accountID) .filter(\.$user.$id == user.requireID()) .first() != nil else { throw Abort(.notFound, reason: "Счет не найден") } let transactions = try await Transaction.query(on: req.db) .group(.or) { or in or.filter(\.$senderAccount.$id == accountID) or.filter(\.$receiverAccount.$id == accountID) } .sort(\.$createdAt, .descending) .all() return try transactions.map { transaction in let senderNumber = try await transaction.$senderAccount.get(on: req.db).accountNumber let receiverNumber = try await transaction.$receiverAccount.get(on: req.db).accountNumber return transaction.toPublic( senderNumber: senderNumber, receiverNumber: receiverNumber ) } } let adminAccounts = accounts.grouped(User.adminMiddleware()) adminAccounts.patch(":accountID", "block") { req async throws -> Account.Public in guard let accountID = req.parameters.get("accountID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID счета") } guard let account = try await Account.find(accountID, on: req.db) else { throw Abort(.notFound, reason: "Счет не найден") } account.status = .frozen try await account.save(on: req.db) return account.toPublic() }
} private func generateAccountNumber() -> String { let prefix = "QL7" let randomDigits = (0..<16).map { _ in "0123456789".randomElement()! } return prefix + String(randomDigits)
} extension User { static func adminMiddleware() -> Middleware { AsyncMiddleware { req, next in let user = try req.auth.require(User.self) guard user.role == .admin else { throw Abort(.forbidden, reason: "Требуются права администратора") } return try await next.respond(to: req) } }
}