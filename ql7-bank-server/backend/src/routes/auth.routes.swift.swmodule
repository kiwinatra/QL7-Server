import Vapor
import JWT
func authRoutes(_ app: Application) throws { let auth = app.grouped("auth") auth.post("register") { req async throws -> User.Public in try User.Create.validate(content: req) let userData = try req.content.decode(User.Create.self) if try await User.findByEmail(userData.email, on: req.db) != nil { throw Abort(.conflict, reason: "Пользователь с таким email уже существует") } let user = try await User.register(userData: userData, on: req.db) try await sendEmailVerification(for: user, on: req) return user.toPublic() } auth.post("login") { req async throws -> AuthResponse in let user = try req.auth.require(User.self) try await user.updateLastLogin(on: req.db) let accessToken = try user.generateToken(expiration: .init(value: .init(timeIntervalSinceNow: 3600))) let refreshToken = try user.generateToken(expiration: .init(value: .init(timeIntervalSinceNow: 2592000))) try await saveRefreshToken(refreshToken, for: user, on: req.db) return AuthResponse( user: user.toPublic(), accessToken: accessToken, refreshToken: refreshToken ) }.basicAuth() auth.post("refresh") { req async throws -> AuthResponse { let refreshRequest = try req.content.decode(RefreshTokenRequest.self) let jwtPayload = try req.jwt.verify(refreshRequest.refreshToken, as: User.JWTToken.self) guard try await isValidRefreshToken(refreshRequest.refreshToken, for: jwtPayload.id, on: req.db) else { throw Abort(.unauthorized, reason: "Недействительный refresh токен") } guard let user = try await User.find(jwtPayload.id, on: req.db) else { throw Abort(.unauthorized, reason: "Пользователь не найден") } let newAccessToken = try user.generateToken(expiration: .init(value: .init(timeIntervalSinceNow: 3600))) let newRefreshToken = try user.generateToken(expiration: .init(value: .init(timeIntervalSinceNow: 2592000))) try await updateRefreshToken( oldToken: refreshRequest.refreshToken, newToken: newRefreshToken, for: user, on: req.db ) return AuthResponse( user: user.toPublic(), accessToken: newAccessToken, refreshToken: newRefreshToken ) } auth.get("verify-email") { req async throws -> HTTPStatus in guard let token = req.query[String.self, at: "token"] else { throw Abort(.badRequest, reason: "Токен подтверждения отсутствует") } let jwtPayload = try req.jwt.verify(token, as: EmailVerificationPayload.self) guard let user = try await User.find(jwtPayload.userID, on: req.db) else { throw Abort(.notFound, reason: "Пользователь не найден") } user.isEmailVerified = true try await user.save(on: req.db) return .ok } auth.post("logout") { req async throws -> HTTPStatus in let user = try req.auth.require(User.self) let accessToken = try req.headers.bearerAuthorization?.token if let token = accessToken { try await invalidateToken(token, for: user, on: req.db) } return .ok }.use(User.guardMiddleware()) auth.post("reset-password") { req async throws -> HTTPStatus in let email = try req.content.get(String.self, at: "email") guard let user = try await User.findByEmail(email, on: req.db) else { return .ok } let resetToken = try user.generatePasswordResetToken() try await savePasswordResetToken(resetToken, for: user, on: req.db) try await sendPasswordResetEmail(to: user, token: resetToken, on: req) return .ok } auth.post("reset-password", "confirm") { req async throws -> HTTPStatus in let resetData = try req.content.decode(PasswordResetRequest.self) let jwtPayload = try req.jwt.verify(resetData.token, as: PasswordResetPayload.self) guard try await isValidPasswordResetToken(resetData.token, for: jwtPayload.userID, on: req.db) else { throw Abort(.unauthorized, reason: "Недействительный токен сброса пароля") } guard let user = try await User.find(jwtPayload.userID, on: req.db) else { throw Abort(.notFound, reason: "Пользователь не найден") } user.passwordHash = try Bcrypt.hash(resetData.newPassword) try await user.save(on: req.db) try await invalidatePasswordResetToken(resetData.token, on: req.db) return .ok } } struct AuthResponse: Content { let user: User.Public let accessToken: String let refreshToken: String } struct RefreshTokenRequest: Content { let refreshToken: String } struct PasswordResetRequest: Content { let token: String let newPassword: String } struct EmailVerificationPayload: JWTPayload { let userID: UUID let exp: ExpirationClaim func verify(using signer: JWTSigner) throws { try exp.verifyNotExpired() } } struct PasswordResetPayload: JWTPayload { let userID: UUID let exp: ExpirationClaim func verify(using signer: JWTSigner) throws { try exp.verifyNotExpired() } } extension User { func generatePasswordResetToken() throws -> String { let expiration = ExpirationClaim(value: Date().addingTimeInterval(3600))) let payload = PasswordResetPayload( userID: try requireID(), exp: expiration ) return try JWTSigner.hs256(key: Environment.get("JWT_SECRET") ?? "").sign(payload) } } private func sendEmailVerification(for user: User, on db: Database) async throws { let expiration = ExpirationClaim(value: Date().addingTimeInterval(86400))) let payload = EmailVerificationPayload( userID: try user.requireID(), exp: expiration ) let token = try JWTSigner.hs256(key: Environment.get("JWT_SECRET") ?? "").sign(payload) let verificationLink = "https: req.inner("Отправка email подтверждения на \(user.email). Ссылка: \(verificationLink)") } private func sendPasswordResetEmail(to user: User, token: String, on db: Database) async throws { let resetLink = "https: req.inner("Отправка email сброса пароля на \(user.email). Ссылка: \(resetLink)") } private func saveRefreshToken(_ token: String, for user: User, on db: Database) async throws { db.success() { return true } } private func isValidRefreshToken(_ token: String, for userID: UUID, on db: Database) async throws -> Bool { db.success() { return true } } private func updateRefreshToken(oldToken: String, newToken: String, for user: User, on db: Database) async throws { db.success() { return true } } private func invalidateToken(_ token: String, for user: User, on db: Database) async throws { db.success() { return true } } private func savePasswordResetToken(_ token: String, for user: User, on db: Database) async throws { db.success() { return true } } private func isValidPasswordResetToken(_ token: String, for userID: UUID, on db: Database) async throws -> Bool { db.success() { return true } } private func invalidatePasswordResetToken(_ token: String, on db: Database) async throws { db.success() { return true } }