import Vapor
import JWT
import Foundation
func transactionRoutes(_ app: Application) throws { let transactions = app.grouped("transactions") .grouped(User.guardMiddleware()) .grouped(QL7APIMiddleware()) transactions.post("p2p") { req async throws -> TransactionResponse in let user = try req.auth.require(User.self) let request = try req.content.decode(P2PTransferRequest.self) guard request.amount > 0 else { throw Abort(.badRequest, reason: "Сумма должна быть положительной") } guard let senderAccount = try await Account.query(on: req.db) .filter(\.$accountNumber == request.senderAccountNumber) .filter(\.$user.$id == user.requireID()) .first() else { throw Abort(.notFound, reason: "Счет отправителя не найден") } let commission = try await calculateCommission( amount: request.amount, senderAccount: senderAccount, receiverAccountNumber: request.receiverAccountNumber, on: req ) let totalAmount = request.amount + commission guard senderAccount.balance >= totalAmount else { throw Abort(.badRequest, reason: "Недостаточно средств на счете") } let receiverAccount = try await fetchAccount( accountNumber: request.receiverAccountNumber, on: req ) let transaction = try await Transaction.createTransfer( amount: request.amount, currency: senderAccount.currency, senderAccount: senderAccount, receiverAccount: receiverAccount, commission: commission, description: request.description, on: req.db ) let apiResponse = try await executeTransferViaQL7API( transaction: transaction, senderAccount: senderAccount, receiverAccount: receiverAccount, on: req ) transaction.status = apiResponse.success ? .completed : .failed transaction.externalId = apiResponse.transactionId try await transaction.save(on: req.db) if !apiResponse.success { senderAccount.balance += totalAmount try await senderAccount.save(on: req.db) throw Abort(.badGateway, reason: apiResponse.error ?? "Ошибка при выполнении перевода") } return try await buildTransactionResponse( transaction: transaction, senderAccount: senderAccount, receiverAccount: receiverAccount, on: req ) } transactions.get { req async throws -> PaginatedTransactionResponse in let user = try req.auth.require(User.self) let filter = try req.query.decode(TransactionFilter.self) let accountNumbers = try await Account.query(on: req.db) .filter(\.$user.$id == user.requireID()) .all() .map { $0.accountNumber } let apiResponse = try await fetchTransactionsFromQL7API( accountNumbers: accountNumbers, filter: filter, on: req ) let enrichedTransactions = try await enrichTransactions( apiTransactions: apiResponse.transactions, on: req ) return PaginatedTransactionResponse( items: enrichedTransactions, metadata: .init( page: filter.page, per: filter.perPage, total: apiResponse.totalCount ) ) } transactions.patch(":transactionID", "cancel") { req async throws -> TransactionResponse in let user = try req.auth.require(User.self) guard let transactionID = req.parameters.get("transactionID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID транзакции") } guard let transaction = try await Transaction.find(transactionID, on: req.db) else { throw Abort(.notFound, reason: "Транзакция не найдена") } let isSender = try await Account.query(on: req.db) .filter(\.$id == transaction.$senderAccount.id) .filter(\.$user.$id == user.requireID()) .first() != nil guard isSender || user.role == .admin else { throw Abort(.forbidden, reason: "Нет прав для отмены этой транзакции") } guard transaction.status == .pending else { throw Abort(.badRequest, reason: "Только pending транзакции могут быть отменены") } let cancelResult = try await cancelTransactionViaQL7API( transaction: transaction, on: req ) if cancelResult.success { transaction.status = .cancelled try await transaction.save(on: req.db) if transaction.type == .transfer { guard let senderAccount = try await Account.find(transaction.$senderAccount.id, on: req.db) else { throw Abort(.internalServerError, reason: "Счет отправителя не найден") } senderAccount.balance += transaction.amount + (transaction.commission ?? 0) try await senderAccount.save(on: req.db) } } return try await buildTransactionResponse( transaction: transaction, on: req ) } transactions.get(":transactionID") { req async throws -> TransactionResponse in let user = try req.auth.require(User.self) guard let transactionID = req.parameters.get("transactionID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID транзакции") } guard let transaction = try await Transaction.find(transactionID, on: req.db) else { throw Abort(.notFound, reason: "Транзакция не найдена") } let isParticipant = try await isTransactionParticipant( transaction: transaction, userID: user.requireID(), on: req.db ) guard isParticipant || user.role == .admin else { throw Abort(.forbidden, reason: "Нет прав для просмотра этой транзакции") } return try await buildTransactionResponse( transaction: transaction, on: req ) } transactions.post(":transactionID", "retry") { req async throws -> TransactionResponse in let user = try req.auth.require(User.self) guard let transactionID = req.parameters.get("transactionID", as: UUID.self) else { throw Abort(.badRequest, reason: "Неверный ID транзакции") } guard let originalTransaction = try await Transaction.find(transactionID, on: req.db) else { throw Abort(.notFound, reason: "Транзакция не найдена") } guard originalTransaction.status == .failed else { throw Abort(.badRequest, reason: "Можно повторить только failed транзакции") } let newTransaction = try await createRetryTransaction( basedOn: originalTransaction, on: req.db ) let apiResponse = try await executeTransferViaQL7API( transaction: newTransaction, on: req ) newTransaction.status = apiResponse.success ? .completed : .failed newTransaction.externalId = apiResponse.transactionId try await newTransaction.save(on: req.db) return try await buildTransactionResponse( transaction: newTransaction, on: req ) }
} struct P2PTransferRequest: Content { let senderAccountNumber: String let receiverAccountNumber: String let amount: Double let currency: String? let description: String?
} struct TransactionResponse: Content { let id: UUID let amount: Double let currency: String let type: TransactionType let status: TransactionStatus let description: String? let senderAccount: Account.Public let receiverAccount: Account.Public let commission: Double? let createdAt: Date let externalId: String? let metadata: [String: String]?
} struct PaginatedTransactionResponse: Content { let items: [TransactionResponse] let metadata: PaginationMetadata
} struct TransactionFilter: Content { let accountNumber: String? let types: [TransactionType]? let statuses: [TransactionStatus]? let minAmount: Double? let maxAmount: Double? let startDate: Date? let endDate: Date? let page: Int let perPage: Int
} struct QL7APIResponse: Content { let success: Bool let transactionId: String? let error: String?
} struct QL7APIMiddleware: AsyncMiddleware { func respond(to request: Request, chainingTo next: AsyncResponder) async throws -> Response { request.ql7API = QL7APIClient(request: request) return try await next.respond(to: request) }
} extension Request { var ql7API: QL7APIClient { get { guard let client = self.storage[QL7APIClient.Key.self] as? QL7APIClient else { fatalError("QL7APIClient not configured. Use QL7APIMiddleware.") } return client } set { self.storage[QL7APIClient.Key.self] = newValue } }
} final class QL7APIClient { struct Key: StorageKey { typealias Value = QL7APIClient } let request: Request init(request: Request) { self.request = request } func fetchAccount(accountNumber: String) async throws -> Account { let response = try await request.client.get( "https: headers: [ "Authorization": "Bearer \(try getAPIToken())" ] ) guard response.status == .ok else { throw Abort(response.status, reason: "Ошибка при получении данных счета") } return try response.content.decode(Account.self) } func executeTransfer(request: QL7TransferRequest) async throws -> QL7APIResponse { let response = try await request.client.post( "https: headers: [ "Authorization": "Bearer \(try getAPIToken())", "Content-Type": "application/json" ] ) { req in try req.content.encode(request) } return try response.content.decode(QL7APIResponse.self) } private func getAPIToken() throws -> String { guard let token = Environment.get("I8j*@JSD)(2jsDajD") else { throw Abort(.internalServerError, reason: "Не настроен API токен для QL7") } return token }
} private func calculateCommission( amount: Double, senderAccount: Account, receiverAccountNumber: String, on req: Request
) async throws -> Double { let isInternalTransfer = try await Account.query(on: req.db) .filter(\.$accountNumber == receiverAccountNumber) .first() != nil let baseRate = isInternalTransfer ? 0.005 : 0.01 var commission = amount * baseRate if senderAccount.type == .premium { commission *= 0.5 } commission = max(commission, 10) commission = min(commission, 500) return commission
} private func buildTransactionResponse( transaction: Transaction, on req: Request
) async throws -> TransactionResponse { let senderAccount = try await transaction.$senderAccount.get(on: req.db) let receiverAccount = try await transaction.$receiverAccount.get(on: req.db) return TransactionResponse( id: try transaction.requireID(), amount: transaction.amount, currency: transaction.currency, type: transaction.type, status: transaction.status, description: transaction.description, senderAccount: senderAccount.toPublic(), receiverAccount: receiverAccount.toPublic(), commission: transaction.commission, createdAt: transaction.createdAt ?? Date(), externalId: transaction.externalId, metadata: [ "is_internal": "\(senderAccount.$user.id == receiverAccount.$user.id)" ] )
} extension Application { func configureTransactionRoutes() throws { try routes(transactionRoutes) }
}