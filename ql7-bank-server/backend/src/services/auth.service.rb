require 'bcrypt'
require 'jwt'
require 'securerandom'
class AuthService JWT_SECRET = ENV[''] || Rails.application.credentials.jwt_secret JWT_ALGORITHM = 'HS256' ACCESS_TOKEN_EXP = 1.hour REFRESH_TOKEN_EXP = 30.days def initialize(current_user = nil) @current_user = current_user end # Регистрация нового пользователя def register(user_params) validate_registration_params(user_params) user = User.new( email: user_params[:email].downcase, password_hash: encrypt_password(user_params[:password]), first_name: user_params[:first_name], last_name: user_params[:last_name], phone: user_params[:phone], role: :user, status: :pending ) if user.save send_email_verification(user) { user: user.as_json(only: [:id, :email, :first_name, :last_name]), status: :created } else { errors: user.errors.full_messages, status: :unprocessable_entity } end rescue => e { error: e.message, status: :bad_request } end # Аутентификация пользователя def login(email, password) user = User.find_by(email: email.downcase) unless user && valid_password?(password, user.password_hash) return { error: 'Invalid email or password', status: :unauthorized } end unless user.active? return { error: 'Account is not active', status: :forbidden } end # Обновляем время последнего входа user.update(last_login_at: Time.current) # Генерируем токены access_token = generate_jwt(user, ACCESS_TOKEN_EXP) refresh_token = generate_jwt(user, REFRESH_TOKEN_EXP) save_refresh_token(user, refresh_token) { user: user.as_json(only: [:id, :email, :first_name, :last_name, :role]), access_token: access_token, refresh_token: refresh_token, status: :ok } end # Обновление access token с помощью refresh token def refresh_token(refresh_token) payload = decode_jwt(refresh_token) user = User.find(payload['user_id']) unless valid_refresh_token?(user, refresh_token) return { error: 'Invalid refresh token', status: :unauthorized } end new_access_token = generate_jwt(user, ACCESS_TOKEN_EXP) new_refresh_token = generate_jwt(user, REFRESH_TOKEN_EXP) # Обновляем refresh token в базе update_refresh_token(user, refresh_token, new_refresh_token) { access_token: new_access_token, refresh_token: new_refresh_token, status: :ok } rescue JWT::DecodeError, JWT::ExpiredSignature { error: 'Invalid or expired token', status: :unauthorized } end # Выход пользователя def logout(access_token, refresh_token) if @current_user && refresh_token invalidate_refresh_token(@current_user, refresh_token) end # Добавляем access token в blacklist JwtBlacklist.create(token: access_token, expires_at: Time.current + ACCESS_TOKEN_EXP) { message: 'Successfully logged out', status: :ok } end # Подтверждение email def verify_email(token) payload = decode_jwt(token) user = User.find(payload['user_id']) if user.email_verified? return { error: 'Email already verified', status: :bad_request } end user.update(is_email_verified: true, status: :active) { message: 'Email successfully verified', status: :ok } rescue JWT::DecodeError, JWT::ExpiredSignature { error: 'Invalid or expired token', status: :unauthorized } end # Сброс пароля def request_password_reset(email) user = User.find_by(email: email.downcase) return { status: :ok } unless user # Security: don't reveal if user exists reset_token = generate_password_reset_token(user) send_password_reset_email(user, reset_token) { message: 'Password reset instructions sent', status: :ok } end # Подтверждение сброса пароля def reset_password(token, new_password) payload = decode_jwt(token) user = User.find(payload['user_id']) unless valid_password_reset_token?(user, token) return { error: 'Invalid or expired token', status: :unauthorized } end user.update(password_hash: encrypt_password(new_password)) invalidate_password_reset_token(user, token) { message: 'Password successfully reset', status: :ok } rescue JWT::DecodeError, JWT::ExpiredSignature { error: 'Invalid or expired token', status: :unauthorized } end private # Валидация параметров регистрации def validate_registration_params(params) raise 'Email is required' unless params[:email].present? raise 'Password is required' unless params[:password].present? raise 'First name is required' unless params[:first_name].present? raise 'Last name is required' unless params[:last_name].present? raise 'Email already exists' if User.exists?(email: params[:email].downcase) end # Генерация JWT токена def generate_jwt(user, expiration) payload = { user_id: user.id, email: user.email, role: user.role, exp: (Time.current + expiration).to_i } JWT.encode(payload, JWT_SECRET, JWT_ALGORITHM) end # Декодирование JWT токена def decode_jwt(token) JWT.decode(token, JWT_SECRET, true, { algorithm: JWT_ALGORITHM }).first end # Шифрование пароля def encrypt_password(password) BCrypt::Password.create(password) end # Проверка пароля def valid_password?(password, hash) BCrypt::Password.new(hash) == password end # Отправка email подтверждения def send_email_verification(user) token = generate_jwt(user, 24.hours) # В реальном приложении здесь будет отправка email VerificationMailer.confirm_email(user, token).deliver_later end # Отправка email сброса пароля def send_password_reset_email(user, token) # В реальном приложении здесь будет отправка email PasswordResetMailer.reset_instructions(user, token).deliver_later end # Генерация токена сброса пароля def generate_password_reset_token(user) token = generate_jwt(user, 1.hour) user.update(password_reset_token: token, password_reset_sent_at: Time.current) token end # Сохранение refresh токена def save_refresh_token(user, token) user.refresh_tokens.create(token: token, expires_at: Time.current + REFRESH_TOKEN_EXP) end # Проверка валидности refresh токена def valid_refresh_token?(user, token) user.refresh_tokens.where(token: token) .where('expires_at > ?', Time.current) .exists? end # Обновление refresh токена def update_refresh_token(user, old_token, new_token) refresh_token = user.refresh_tokens.find_by(token: old_token) refresh_token.update( token: new_token, expires_at: Time.current + REFRESH_TOKEN_EXP ) end # Инвалидация refresh токена def invalidate_refresh_token(user, token) user.refresh_tokens.where(token: token).delete_all end # Проверка валидности токена сброса пароля def valid_password_reset_token?(user, token) user.password_reset_token == token && user.password_reset_sent_at > 1.hour.ago end # Инвалидация токена сброса пароля def invalidate_password_reset_token(user, token) user.update(password_reset_token: nil, password_reset_sent_at: nil) end
end